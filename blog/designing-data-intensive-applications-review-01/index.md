---
layout: post
id: 24
title: "데이터 중심 애플리케이션 설계 리뷰"
subtitle: "Part 1"
description: "책을 읽으면서 내용을 정라하며 기록"
type: "Book"
created_at: "2022-01-29"
updated_at: "2022-01-31"
blog: true
text: true
author: "silnex"
post-header: true
header-img: "img/book-cover.png"
order: 24
tags: ["DDIA", "book", "review"]
comments: true
---

# 믿을 수 있는 애플리케이션의 조건들

## 신뢰성

"결함"이 있더라도, 사용자가 예상하는 기능을 "올바르게" 제공해야 함을 의미합니다.
하지만 이러한 결함들이 **0** 이 될 수는 없는 법이다.  
그렇기에 각 결함에 대한 **예방**과 결함 해소를 위한 **훈련** 그리고 우발적인 결함을 피하기 위한 **규율**이 필요하다.

- 하지만 무한한 신뢰성을 위한다기보단, 비용과 신뢰 사이에 애플리케이션에 맞는 타협 가능한 지점을 찾는 것이 가장 중요하다고 생각한다.

## 확장성

확장을 위해선 현재 **부하의 측정**이 가능해야하고, 목표로 하는 **처리 성능**을 모니터링 해야한다.

- 처리 성능에 대한 예  
  "응답시간 백분위"를 통해 부하의 측정를 통해 목표하는 응답시간 (처리 성능)을 이끌어냄

## 유지보수성

애플리케이션은 변한다. 그렇기에 수정할 수 있어야한다.

하지만 복잡하면 수정하기 어렵다. 그렇기에 **단순**해야한다.

그러니 **추상화**가 필요하다. 하지만 추상화는 언제나 그렇듯이 더럽게 어렵다. <del>(문과를 나왓어야 했나..)</del>

# 데이터 모델과 질의 언어

데이터 모델과 이를 사용하는 객체와는 항상 불일치가 있다.

관계형, 문서형 등 다양한 데이터 모델에 대한 논쟁은 예나 지금이나 끊이지 않는다.

- 그렇기에 각각의 장,단점을 알고 이에 맞게 사용해야한다.

하지만 최근 관계형과 문서형의 차이는 점검 줄어들고 있으며, 서로를 상호 보안하는 방향으로 발전하고 있다.

# 저장소와 탐색

> [참고 링크](https://johngrib.github.io/wiki/d-i-a-03-storage-and-retrieval/)

데이터는 수정 사항들이 파일 뒷편에 추가만 되며, 주기적으로 합쳐서 최신 변경사항과 만일 발생하는 문제 상황에 대비한다.

- 예) `a:1|b:2`이와 같이 저장되어있을 때 `a`를 `0`로 수정하면, `a:1|b:2|a:0` 와 같이 추가되며, 이후 합쳐(컴팩션)지는 처리를 통해 `a: 2|b: 2` 이와 같은 방식으로 저장합니다.

## 해시 색인

`a:1|b:2` 와같이 저장되어 있을 때 메모리 상에 `a:0번째부터`, `b:5번째부터`와 같이 offset을 저장해두고 빠르게 찾아가는 방식이다.

특징

- 간단한 방식이지만, 많이 사용하는 방식이다.
- 모든 키가 메모리에 저장된다는 전제하에 고성능 읽기 쓰기를 보장한다.

문제점

- 키가 많으면 그만큼 메모리를 많이 소비함
- 범위 검색엔 취약함

## SS 테이블

모든 데이터의 키를 저장하는 것이 아닌 정렬된 부분적인 정보만을 저장해두고 짧은 범위에서 검색합니다.

`a:1|b:2|c:3|d:4` 와같이 저장되어 있을 때 메모리 상에는 `a:0번째부터`, `c:9번째부터` 와 같이 저장되어 있고, `b`를 찾을 때 메모리에있는 `a`와 `c`의 정보를 통해 **0 번째 ~ 9 번째** 사이에 `b`가 있다는 것을 알 수 있다.

- 모든 키를 메모리 상에 상주시키지 않기에 적은 메모리 유지함
- 정렬되어 저장하기에 데이터 정렬시 유리하다.

## SS 테이블에서 LSM 트리 만들기

LSM 트리의 기본 개념: 백그라운드에서 SS 테이블을 지속적으로 병합한다.

## B 트리

- 가장 널리 사용되는 색인 구조이다.
- 대부분의 DB에서 B 트리를 사용한다.

### B 트리에 존재하는 키 값 갱신

- 키를 포함하고 있는 리프 페이지를 검색한다.
- 페이지의 값을 바꾼다.
- 페이지를 디스크에 기록한다.

### B 트리에 새로운 키를 추가하기

- 새로운 키를 포함하는 범위의 페이지를 찾고 해당 범위의 페이지에 키와 값을 추가한다.
- 페이지에 공간이 부족하다면, 페이지를 절반으로 쪼개고, 상위 페이지의 링크를 갱신한다.

위의 알고리즘은 트리가 계속 균형을 유지하는 것을 보장하고, n개의 키를 가진 B 트리는 깊이가 항상 `O(log n)` 이다.

## 기타 색인 구조

- 보조 색인
- 색인 안에 색인된 로우를 저장
- 색인 안에 테이블의 칼럼 일부를 저장
- 다중 칼럼 색인 (결합 색인, 다차원 색인)

## 트랜잭선 처리나 분석?

- 온라인 트랜잭션 처리(OnLine Transaction Processing, OLTP)
- 온라인 분석 처리(OnLine Analytic Processing, OLAP)

|      특성      |            트랜잭션 처리 시스템(OLTP)            |        분석 시스템(OLAP)         |
| :------------: | :----------------------------------------------: | :------------------------------: |
| 주요 읽기 패턴 |   질의당 적은 수의 레코드, 키 기준으로 가져옴    |     많은 레코드에 대한 집계      |
| 주요 쓰기 패턴 | 임의 접근, 사용자 입력을 낮은 지연 시간으로 기록 |  대규모 불러오기, 이벤트 스트림  |
|  주요 사용처   |        웹 애플리케이션을 통한 최종 사용자        | 의사결정 지원을 위한 내부 분석가 |
|  데이터 표현   |                데이터의 최신 상태                | 시간이 지나며 일어난 이벤트 이력 |
| 데이터셋 크기  |            기가바이트에서 테라바이트             |    테라바이트에서 페타바이트     |
|                |                 사업 운영에 중요                 |                                  |
|                | 높은 가용성, 낮은 지연 시간의 트랜잭션 처리 기대 |                                  |
|      병목      |                   디스크 탐색                    |          디스크 대역폭           |
